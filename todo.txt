
	* valid scheme characters: + - . * / < = > ! ? : $ _ & ~ ^

    Discussion:

      Multiple Characters:
	* make it possible to play multiple characters at once, perhaps by having a special channel with the character's name
	  and use it as the control, like #realm for that character.  There could be a limit of 4 or so concurrent character logins
	  per connection.  You could be able to control a whole party through different channel windows.  Perhaps there could be a
	  number of 'characters' in the user object, and the user object can be in a different special non-playing area for social
	  MUDing, while his/her characters can be in various parts of the game area.  So maybe it should be #realm even, maybe
	  #social, and #realm-char can be used for each character.  It is possible to make #realm just a channel and use the evaluate
	  action to implement all world manipulation
	* it might be possible to do multiple characters such that you just make an object with all the same basic actions on it
	  as a user object such that they forward the calls on to the user object accordingly.  The user would then direct all possible
	  output to the character object by calling actions in a certain channel (possibly the character itself... is this possible??)
	  Mighten this require the use of child/parent object linking (perhaps even just a property list of the child objects, which
	  could be maintained by the clone function or something).

      Interface Methods:
	* should MooInterface use a MooTask as the handler, or should it make a custom handler class like MooTimer does?
	* you could implement a telnet per-user-connection-task (like pseudoserv) which uses ANSI codes to create a simple client
	  interface.  It would interact with the objects in the same way as pseudoserv
	* the 2 other IRC interface methods (client connected as TheRealm, privmsgs are directly interpreted as commands, output is
	  directly printed, exactly the same as it would appear on telnet (more or less), -OR- server based, either the same as the
	  client (but with services-like permissions), or ... actually the method with #realm wont work with multiple IRC servers,
	  since all users associated with that channel will receive the same text, so everyone will recieve everyone else's private
	  traffic.  #realm could be use for only talking, with notices being sent for status messages, but that would get really
	  annoying since the notices might appear in other windows (dependant on client).  However, a system of #324 numeric channels
	  or something like that would still be possible (channels could be +si or something, so that you can only join if you are
	  forcejoin'd by TheRealm.)  (Note: the number used in numeric channels cannot be the room unless you are force join/part'd)

      MultiTasking:
	* tasks should be small temporary things, like a new task for each fight.  They should not be directly equivallent to threads
	* you could have a tasks/ directory the same as the current objs/ directory, such that each task ID coresponds to a numbered
	  file in the tasks/ directory and stored in that is the task state such that it can be restarted using that information.
	  A task that saves it's state would be persistent.  Not all tasks need (or should) be persistent.
	* you could have a locking mechanism in the frame itself similar to the task suid mechanism, where an unlock event is placed
	  on the stack.  Then, when a frame is going to be suspended, it can check for a lock and continue execution until the unlock
	  is reached.  It can also monitor for overrun and terminate the task or something.
	* perhaps you could add a lock/unlock method pair to MooObject or MooThing such that you pass it a pointer to the user (or
	  object, or task, or something) that is trying to lock an object.  If you are using multithreading, it will use a semaphore
	  or else just a bit and if successfully lock, will save the pointer passed to it.  That pointer can then be used to determine
	  who is performing an operation on that object (for permission checking) while at the same time allowing multithreading
	* should we have a fixed number of worker threads, and have them access an mqueue of scheduled tasks and have them just
	  constantly consume a task and run it (possibly until done, possibly for a limited time).  Is there a big benifit in not
	  having a thread per task? (creating/destroying a thread for every task create/destroy)

	* how will any code (assuming we use pthreads) be able to get the current task (the only thing needed usually is the owner of
	  the task, and the user)?  We can't use global variables like we are.  I guess this depends on the whole threading mechanism
	* should all timing have to be done with tasks?  You could have scheduled tasks which execute after a specific amount of time,
	  and you could also have a sleep function which suspends the task for a specific amount of time.
	* how will you be able to do register/create_character when you need to ask a bunch of questions.  It would be nice if it
	  was interactive.  It could possibly be implemented, such that .say gets redirected to a thing (perhaps by placing the user in
	  the thing itself, like a room. thing->do_action("say")).  We could alternatively have the registration "thing" call notify
	  with a special message telling it to prompt the user for input and returning it.  The task responding to the notify (or
	  possibly the user's notify function which mearly calls task's notify. NO IT SHOULD BE POSSIBLY FOR TASKS TO DO INTERFACE
	  SPECIFIC PROMPTS) can then redirect any input it receives to the registration thing

	* how will 'notify' relate to tasks and all that?  Will it be a message system for passing messages to a task?
	* we could have a message queue for each task such that certain functions (handling notify() calls or handling interface-ready
	  or timer expire events or something) can be performed later.  It could be a fairly generic mechanism
	* notify can either be like an interrupt, where in a code task, the notify execution code would be pushed directly onto the
	  task's frame, so that it's executed immediately, no matter what is currently executing (or alternatively, somewhere in the
	  frame that we know is safe).
	* when data is available at the socket, you would normally "switch" to the handling task, and then call the handler.  In
	  pseudoserv, we the use call_method to create a frame and run the command, inline, but if we want to eliminate the detached
	  frames (1 frame always belongs to 1 task), then we would either evaluate this command on the pseudoserv frame, which would
	  then need to be evaluated seperately (idle() would be called by an idle-processing worker thread), or we could make a new
	  task (with a frame) and evaluate the command in there.  This would mean you could fork tasks by executing a command, and
	  commands could run for a time without having to create their own tasks.  For example, fighting could be implemented directly
	  in the command itself, so the fight command would just run and use 'sleep' or something to pause between rounds.  Not all
	  instances of call_method could be replaced with this methods, since some are just doing something simple and don't need a
	  whole task, so you'd probably still need both methods (pseudoserv has it's own code frame, and also creates new code frame tasks
	  for executing commands).
	* we could turn socket-data-ready callbacks into notify() calls and use the same mechanism for handling them
	* notify could be a function or method defined in an environment, which all tasks would have (MooTask), and then in pseudoserv's
	  case, it would be a MooFunc type definition to a builtin function.  We could eliminate the indirection (user:notify)
	* you could have a queue type which is stored as just a normal property in the user object, instead of storing the task??
	* you could have a queue of messages for each task (notify events, handling, etc) and still have a single task run function in
	  each task, and have the run function call a function to process and dispatch notify messages automatically (for convenience).
	  For pseudoserv and stuff, it's ok because they don't use their current idle() functions so that would become a run() function
	  and would have a loop that blocks trying to read the queue, thus waiting until a message arrives.  Everything else in the
	  server could be handled in this way (besides pinging clients and detecting timeouts, which could be incorporated into the
	  read_and_dispatch() function).  For MooCodeTasks, you would have to incorporate the dispatch function inte the frame->run()
	  system by periodically checking if a message is available (non-blocking).  The big problem here is if you use sleep() or
	  somehow want a delay (without creating a new task to delay execution).  If you use the real sleep(), the thread will block,
	  so you'd need 2 threads per task to run; one for the run() function and one for dispatching.  Another way is to somehow use
	  another thread to time or something, or somehow get a special message sent when the time expires, and then the thread can
	  block by waiting to read and dispatch a message, and when it recieves the timeout message, it unsuspends the run.  Another
	  option is to not have a message queue per task, and instead, special tasks will be able to receive a message, like pseudoserv
	  and everything else would be handled via thing methods (tell and functions like that would all just be methods and only the
	  user object would have a tell function which calls task:notify or something like that, or else which pushes the message onto
	  a queue, which pseudoserv can (with thread-safety built in to queue) consume messages from that queue and process them as it
	  currently does.  We would still need a way to handle network events, but perhaps that could be integrated using a similar
	  mechanism (register a queue object with interfaces, and have interfaces' select() function to write a message to that queue,
	  and for pseudoserv, you'd give it the same queue as the user's queue (we'd create the queue first when the task starts and
	  assign it to the user once we connect).  This would again, however, not work for MooCodeTask, because it is not already
	  waiting on a queue.  Then again, MooCodeTasks cannot currently use interfaces anyways, and should not be able to do so easily

	* how would you create a new listener task from MooCode: (new-task %listener 6667 "pseudoserv") ???
	  This would assume that %listener is a global variable of the listener task type (well it's basically just a lambda), and it
	  passes the arguments in the normal way.
	* a (lambda ...) would be the best way to define a task's body, because we use it for everything else (so no special case) but
	  because evaluation of a lambda creates a new env, things defined in the lambda will not be perminent to the task
	* there must be a consistent global environment for every task such that when the task is executed, it's possible to (define ...)
	  things and have them remain in the task's scope at all times (thread-global definitions).

      Permissions:
	* you need to sort out permissions.  You can either have them on all objects or only on environment entries and things.  If you
	  put them in the object themselves, then you can't have the same object added as a property to 2 different things or else the
	  permission changes to one will affect the other.  This is the most significant with the way you are doing nil atm.  With
	  a single value for nil, you can easily compare the pointer instead of doing a dynamic_cast, but you can't assign nil to a
	  property since there is no way for the property itself to have unique permissions (the nil value would have the perms)
	* we could have a public/private flag for each property (permissions) such that some properties are only accessable when they are
	  being accessed on the direct thing.
	* (define &rwxp name value) - you could do this or something like it in order to set permissions during the define.  Also
	  (chmod &rwxp name/value) to keep it consistent, but it'd need to be a form.
	* the biggest issue with permissions is the execute/suid flags.  It is best if these flags are on the value itself, unless
	  some kind of value like MooMethod is *always* returned when calling get_method.  This would then persist at least until the
	  value was evaluated.  It might be possible to remove this whole thing by altering the execution core such that it stores
	  the detailed information in MooArgs or in the CallFunction event or wherever, rather than evaluating the function lookup like
	  all other values.  This would likely make function calls special and not first-class values.
	* can we pass 'this' as a lambda argument instead of it being implied?  Would this actually make it more complicated??

      Miscellaneous:
	* You can use a public/private flag for thing properties so that some properties will be invisible to child things.  This would
	  prevent those errors I had before where complex objcets like arrays and hashes would be the same (contents and stuff).  You
	  could also just use init().

	* you need to fix arguments and command and method processing and stuff.  I like the idea of a seperate namespace for commands
	  because it allows a command to have the same name of a function but with different argument processing and stuff

	* We could have a new undef type to be used when a value is not defined, although this might be confusing having 2 'blank' values

	* how can you delete MooThings from the system?

	* should you remove the period commands and just have the system parse it all out?  All text would be sent to channel:say and
	  that function would then check for a '.something' and send it to channel:command itself
	* you could have a command prefix like '.' such that it doesn't get parsed out of the name but only commands with that prefix
	  are interpreted as commands, therefore all user-accessible commands must have a special name and don't get confused with
	  none-command methods.  It would have to be something else because '.' is used as an accessor in code (would be impossible to
	  have channel:.say for example, but could have channel:@say)
	* this could be entirely object dependant.  In nickserv, the 'say' method will be called when a pm is sent to nickserv.  That
	  method then executes it as a command.

    TODO:

	* add a 'register' and 'login' commands to basics

	* make an (undefine ...) command for completeness!!!  (this should behave exactly like define except it removes entries).
	  this would be the only way to remove a property from an object, since setting nil will not remove the entry.
	* add debug field to event and fix debug message printing

	* add arguments to be passed to 'initialize' during cloning
	* add a (check ...) function to do a permissions check and throw an error, so more complex checks can take place
	* add a (sudo <object> <code>) function which elevates to the given object before executing the code (without requiring SUID)

	* add infinite loop protection
	* review all code for permissions check errors and bugs.  Evaluate system security.
	* check out SMAUG's social.dat stuff and incorporate it possibly
	* if possible/needed, you could have a method on NickServ which goes through all the users at startup and makes sure they are
	  in the cryolocker or something
	* make sure it is not possible for a user to change his/her last_location value, logout, log back in, and get teleported to
	  some place they aren't supposed to be

	* add support for notices from clients to other clients
	* add irc server-to-client pinging & connection timeouts
	* add flood protection of some kind (???)  (could this somehow be an add-on or a coded thing)
	* fix 'quit' function to send an actual quit message to each client rather than just having the user part all channels
	* fill in all other IRC message processing

	* make a regex type (like string) that precompiles the expression, and can be directly parsed in using // notation

	* make it so that not all objects are loaded into the system (your ID assignment hack makes this impossible)
	* modify attribute/colour formatting to use a stack of attribs, and to revert when closed tag is found
	* implement an automatic testing system somehow (so you can verify the moocode core at least)
	* add caching to environments??
	* should you have private environments that are skipped when doing nested lookups?

	* make a pet kitty cat object as a scripting test
	* make a mobile-equivallent of logarithm
	* make a bot which randomly pieces together lojban sentances (which may or may not make sense)
	* make some room games for testing, like trivia, maybe munchkin if you are ambitious, or go fish??


    Old Stuff:
	* parser format:   command[/modifier] [-flags] [object [preposition indirect-object]

	* the biggest problem with any parsing format will be for the get <object> from <container> command
	  specifically.  The object must be searched for in the container which is not normally searched
	  as a location for the direct object.  Either object searching can include an object specified in
	  the command, or wehre to search can be specified in the action definition, or just a string can
	  be passed and it will be up to the action code to resolve the string.
	* make sdm_interpreter_find_thing() use the aliases of an object for matching as well as doing partial
	  matching of the string given.

	* how do you prevent a user from directly calling actions that he shouldn't call directly on the
	  command line
	* add command shortcuts like lambdamoo's \" for say and : for emote

	* add a jump_ok property and maybe even a distant_look_ok or something that allows looking at an
	  object without being nearby
	* perhaps you can add colour theming through the user properties and the expand string notify by
	  having <$caller.error> and so on type tags in string being printed using notify
	* make functions for setting the name and description of an object
	* add actions for manipulating things: get, give, drop, inventory, etc
	* make an "exits" command that prints the list of obvious exits and their descriptions
	* print the equipment, weapons, armour, etc seperately and/or provide commands that print only
	  one type

Structural Issues:

	* should you change format codes to something like bbcode ( [red] instead of <red> )

    Output Formatting/Interfaces:
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).

Gerenal:

	* make the login track invalid attempts and terminate the connection after a while (for all interfaces?)
	* add a way to automatically timeout login attempts (for telnet)
	* implement proper handling of telnet commands

	* make it possible for the command prompt to display info (call a function to generate it)

Features:

	* focus on chatting/social rather than game (for now)
	* make the server multithreaded.  You'd need some kind of semaphore lock on the objects so that calling
	  an action locks the object
	* multiple scripting languages: sdrl, lua (Is this even worth it anymore?)
	* python would be like room.action("look") to run an action, room.get("desc") to get property, etc
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #realm or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #realm channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface
	* include a fully functional editor/construction kit, which could even save the word automatically
	* make a seperate program that can generate a visualization of some kind of parts of the database, so that you can make maps

	* you could have a protocol that would allow object based RPC (via xmlrpc or a custom system or something) such that you could
	  implement both a client connection (calling actions (methods) on the user thing object through which everything can be done)
	  or controlling other objects allowing out of process extensions
	* in future, we could make a client (klunky), services (is this even possible), or server based IRC interface.  If it requires
	  (or would be easier to use) some existing code (like perhaps even writing a module for anope), you could easily just have it
	  act as an RPC client to the Moo Server over a socket (which we have yet to figure out)
	* what are the merits of a disk-based thing database rather than having all objects in memory?  If we were to add this, it
	  could probably be done transparently to the existing code

	* you could have extra data in the xml map file for things like sound, graphics, etc. and have a
	  special client or clients (sdmc, written in C, maybe a flash/web based interface).  These clients
	  could connect using a different interface and processor but get into the same core and interact in
	  the same sort of way.  (interface -> processor -*-> API, where -*-> means many different calls).
	  The client could maybe have predownloaded the data or could pre-cache it automagically from the
	  server.  Maybe map data would be on the fly and tiles and sounds are precached.
	* Each room could have it's own tiled map and going out a room "exit" like a door would be the same
	  as in the text game, transporting you to another room.  Things would still operate on a room
	  basis, so fighting and picking up items and stuff doesn't change based on where you are in the
	  tiled room.  Maybe you might not even be able to move (such as if it's a web-based one).  On the
	  bottom part of the screen would be a console that prints a lot of the text that you would normally
	  see.

