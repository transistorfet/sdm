
	* we could do a registration thing as a special questionaire processor that is configured through
	  xml code that tells what to read in <input name="class" type="number" min="1" max="32">prompt</input>
	  kind of thing.  The values read in would be placed in an sdm_thing object as properties.  An action
	  on that thing would then be called at the end called "finalize" or something that does any
	  additional configuring based on the collected data.  How would you make different subselections
	  based on previous input though (only ask a certain question if the answer to a previous question
	  was a certain answer)?

	* how do you decide what things to print in the list of contents since you don't want to print all
	  objects such as exist and stuff

	* BIG PROB: we assign new user ids based on the next available object id *according to the objects
	  loaded in the system* so since not all users are loaded, we could reassign the same id to a new
	  user which would cause serious problems.  We need a way to syncronize ids between loaded and
	  unloaded objects.  We can't just make an new id be assigned when the user logs on since the objects
	  that the user has will also be effected by this and i don't think all objects should have variable
	  ids.  The only other way would be to keep track of the used ids such that you load the list of ids
	  even if the object isn't loaded...  You could move the users to a special "cryostorage" area when
	  they quit (a place that you should never be able to be in while logged in) thus having a place to
	  "be" while not logged in but still loaded into the system.  You could then have a special swapping
	  system if needed such that objects that aren't used can be written to disk and removed from memory
	  but they can be read back in at any time.

	* clean up sdrl a bit
	* make interface inherit from the object system
	* should all scripting be supported only through actions and if so, i guess we should rename modules/
	  to be actions/ and put the action.c file in there just like we have for interfaces
	* read and write the processor object from the user data file

	* should various fixed values in objects such as id, parent, location, etc be checked/returned as
	  a property using a special check during get_property? or should they be duplicated in the properties
	  list or something?  or have special read-only reference object types or what?
	* implement the writing of action in basic and sdrl
	* make it possible to get the object name given a pointer to the object type (either through a reverse
	  lookup or by storing the name in the type itself) for reading/writing properties and actions
	* you need a way to return an sdm_object from an action (where? is this really need, give example)

	* make functions return void at times such as release_*()s
	* can you make object lookup in the interpreter try to match the whole command line and whatever
	  matches the best is used as the object name and the rest is passed as the args string?
	* change sdm_interpreter_find_object to take a more generic object than sdm_user and to do more
	  searching.  It could take an sdm_thing and look inside the container that contains that thing and
	  if that thing is a container itself, it could look inside itself as well.  Also convert me and here
	  to the appropriate values
	* have an etc/telnet.xml file with <server> entries to run servers and the data on what registration
	  restrictions and objects to use will be there
	* evaluate error handling for all interface stuff
	* evaluate error handling for all non-object code



	* implement a permissions system for object modification
	* make some handy util static inline functions (what ones should i make?)
	* should you make container use the element name to lookup the type of object to create? (with the
	  requirement that the type must extend sdm_thing)
	* should you add a flag to objects somewhere that specifies that the object should be written to a
	  seperate file (sdm_user) for checking when writing a container instead of a hardcoded check for user?
	* (should you) add all object types to the object type list (who makes the calls?)

	* make SDRL convert bare words to variable lookups like lisp would
	* make a proper (if ) and any other handy forms to make it easy to program
	* make a sdrl unparser (perhaps as part of SDRL itself)
	* make functions for controlling the properties of sdm_things
	* make functions for moving objects between containers

	* make the container_find() function continue searching for more complete matches
	* add command shortcuts like lambdamoo's \" for say and : for emote
	* add a system of relative object shortcut names specified in commands like "me" will refer to the
	  user object and "here" refers to the room the user is currently in
	* make system things configurable through xml files such as the port that telnet uses
	* write and implement details on input converting (in the server core format document)
	* tidy up the xml formatting in telnet perhaps and add theme tags (tags that indirectly refer to
	  format)
	* perhaps you can add a binary tree implementation for partial match searches such as commands that
	  can automatically be abbreviated.  You could also perhaps make the container store objects in a
	  in a binary tree for faster accessing

	* make various commands use the extra text passed in a command as a text modifier.  For example you
	  could say "give apple to trans carefully" and it will interpret the command like normal and the
	  'carefully' at the end would be tacked onto the output as "Wizard gives an apple to trans carefully"
	* make telnet use non-colour xml tags as theme colour specifiers

	* add the ability for telnet to read user specific configuration data from the user file
	* implement proper handling of telnet commands
	* have a linked list of processors in the user object with a pointer to the currently active one
	  and read/write the processor's data to the user file.  There should be a function for code to select
	  or create a new processor in the user as well as remove one.  The "next" pointer wolud be in proce..

	* make the login track invalid attempts and terminate the connection after a while
	* add a way to automatically timeout login attempts
	* accept a "-d" command line arg and fork to a daemon process
	* make the login object use/store multiple methods of authentication (primarily for other interfaces)

	* make build.pl only use the cflags for certain modules as needed instead of all modules being
	  compiled with the flags for all embedded languages for example
	* make it easy (through data.c) to have multiple "data modules" (only needed for maps and stuff)
	* make it possible for the command prompt to display info (call a function to generate it)

Refactoring:


Structural Issues:

	* how can you determine what xml element name to use for property objects without having to handle
	  each object type seperatly?
	* when you attempt to perform an action on the user and user's location before the object, you run
	  into issues such as "look" being defined for the location and an object but because you look up
	  the location first, you do the location's look action and not the object's look action even if
	  the object is specified in the look command.  One solution is of course to force these objects to
	  have different commands for "look".  Another option is to be able to specify parameters that an
	  action will accept so only if there are no args will the "look" in location be executed
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* there is a potential problem with xml format codes inside of xml files but only really in terms of
	  manual editing.  Should you store various property strings as CDATA strings or switch to bbcode
	  or do nothing?
	* should there be some way to determine the end of output or the assumption that all output must be
	  put in a single string and written at once such that when the end is reached and the attributes
	  have been changed, a reset attribute command can be sent in case the xml formatting wasn't complete.

	* is the way we call the callbacks in sdm_interface_select right in that we call each callback
	  once *for each condition* so the same function is called with the same interface for each
	  condition that it's registered for.  How does the callback tell the difference?  should there
	  really be 3 callbacks?  Or should you only be able to handle one condition? or should the callback
	  only be called once and it's up to the handling routine to check each descriptor to see which one
	  is ready?  Isn't there a function called poll that can be used instead of select in those situations?

	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).
	* think about the processor system.  it might be good to seperate it such that if a raw xml client
	  was developed, it should be able to communicate directly with the code that handles telnet clients
	  directly ontop of the code that accepts the xml client essentially

Features:

	* multiple scripting languages: sdrl, lua
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #world or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #world channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface

