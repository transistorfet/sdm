
    Discussion:

      Multiple Characters:
	* make it possible to play multiple characters at once, perhaps by having a special channel with the character's name
	  and use it as the control, like #realm for that character.  There could be a limit of 4 or so concurrent character logins
	  per connection.  You could be able to control a whole party through different channel windows.  Perhaps there could be a
	  number of 'characters' in the user object, and the user object can be in a different special non-playing area for social
	  MUDing, while his/her characters can be in various parts of the game area.  So maybe it should be #realm even, maybe
	  #social, and #realm-char can be used for each character.  It is possible to make #realm just a channel and use the evaluate
	  action to implement all world manipulation
	* it might be possible to do multiple characters such that you just make an object with all the same basic actions on it
	  as a user object such that they forward the calls on to the user object accordingly.  The user would then direct all possible
	  output to the character object by calling actions in a certain channel (possibly the character itself... is this possible??)
	  Mighten this require the use of child/parent object linking (perhaps even just a property list of the child objects, which
	  could be maintained by the clone function or something).

      Miscellaneous:
	* by making a subclass of both user and task, which can be used in place of both (task is already ok for this, but user would
	  need some more virtual functions), it would be possible to easily implement an RCP break, such all code can be used to make
	  combinations of either the server or client side of the connection, with minimal effort.  ie. function calls to task, to
	  write to user, can be redirected over an RPC connection, and come out the other side, just as the other side of the function
	  call.  Therefore, we need to work on the RPC system, the IRC system, and the telnet system =P
	* the 2 other IRC interface methods (client connected as TheRealm, privmsgs are directly interpreted as commands, output is
	  directly printed, exactly the same as it would appear on telnet (more or less), -OR- server based, either the same as the
	  client (but with services-like permissions), or ... actually the method with #realm wont work with multiple IRC servers,
	  since all users associated with that channel will receive the same text, so everyone will recieve everyone else's private
	  traffic.  #realm could be use for only talking, with notices being sent for status messages, but that would get really
	  annoying since the notices might appear in other windows (dependant on client).  However, a system of #324 numeric channels
	  or something like that would still be possible (channels could be +si or something, so that you can only join if you are
	  forcejoin'd by TheRealm.)  (Note: the number used in numeric channels cannot be the room unless you are force join/part'd)

	* the editor task could be implemented via whatever protocol by just passing all the code to the client, allowing it to
	  locally edit it, and then passing it back.  Even if an online (server-side) editor is used, it could store all the code in
	  a buffer, edit it, and then pass it all back when done.  How will editing work through IRC?
	* should MooInterface use a MooTask as the handler, or should it make a custom handler class like MooTimer does?

	* add a bitflag to MooThing to indicate that the thing is locked and cannot be replace or deleted.  This could then be set
	  to indicate that a direct pointer is being used.  MooUser could set this bit for the cryolocker to protect it.
	* perhaps you could add a lock/unlock method pair to MooObject or MooThing such that you pass it a pointer to the user (or
	  object, or task, or something) that is trying to lock an object.  If you are using multithreading, it will use a semaphore
	  or else just a bit and if successfully lock, will save the pointer passed to it.  That pointer can then be used to determine
	  who is performing an operation on that object (for permission checking) while at the same time allowing multithreading
	* we could have queued actions (or a special param or something passed to do_action) such that the action data can be copied
	  and placed in a queue to be evaluated later (namely when the object is unlocked, when doing multithreading and stuff).
	* think about multithreading possibilities

	* it might be possible to not use ThingRef and instead use reference counting and garbage collection of pointers to MooThing
	  directly.  Objects could still have an ID but it just wont be used internally as much.
	* should an action be directly passed the object pointer on which the action exists or should it get the pointer to the object
	  on which the action was called (which m_thing would be set to in the args anyways)?
	* could you perhaps add some objects to the properties list as 'constants' so that you could store either the pointer to the
	  MooObject value, or to the value embedded in the object in MooThing itself so that it is easy for C stuff to access directly
	  but is also accessible as a property and no effort is needed to keep both values consistent (since they are the same).
	  Perhaps you could also just say to fuck with it and just always access it as a property (and use accessor functions to make it
	  easier to manipulate in C) (???)
	* should some properties have a fixed type such that a value of another type cannot be assigned and when reading, don't check type?

	* you need a 'thing' garbage collection system, and possible an any-MooObject collection system
	* make it so that you can have a script (either of MooCode or commands or both) such that you can program an entire initial
	  system.  When the code is run, it generates the database which can then be saved as the core database.
	* Another problem though is thing id assignment and the possibility of overlapping IDs.  We could use a
	  quota system such that each object has a certain range of IDs from which it can create new objects.  You could even have
	  limit inheritence such that it looks for the object with the first defined min ID and the first max ID from which it gets
	  its range when creating a new things.  It might still be possible to have overlapping IDs and anyways, you might still have
	  references to objects in other files.  It would improve some things though, and it would allow programming access with limits
	  and you could even contemplate a "relocatable" format, such that it automatically adjusts all IDs (like all thing refs could
	  start allocating from 0 and then the file could be loaded as relocatable (or have a tag at the top) and the loader could
	  decide what range to put them in, so long as it just updates all the IDs as they are loaded.

	* how will you be able to do register/create_character when you need to ask a bunch of questions.  It would be nice if it
	  was interactive.  It could possibly be implemented, such that .say gets redirected to a thing (perhaps by placing the user in
	  the thing itself, like a room. thing->do_action("say")).  We could alternatively have the registration "thing" call notify
	  with a special message telling it to prompt the user for input and returning it.  The task responding to the notify (or
	  possibly the user's notify function which mearly calls task's notify. NO IT SHOULD BE POSSIBLY FOR TASKS TO DO INTERFACE
	  SPECIFIC PROMPTS) can then redirect any input it receives to the registration thing

	* check out Smaug's system/socials.dat.  It has various premade commands for interaction which don't actually do anything
	  other than print various messages to various people but would make a great addition.  Find out what each line is for
	  (it's able to print different messages to different people/objects) and also what variables are available for expansion in
	  the actual strings.

    Covnersion TODO:
	* convert all moo_register_type function calls to rely on exceptions rather than return codes for reporting errors
	* there is currently no point to frames, since we create a new frame every time a lambda or block is evaluated, as well as
	  for actions.  Can we change this all so that only one frame is used?  Should you even try to do that?
	* can you get rid of parse_args()??  Perhaps integrate parts of the interpreter into various other bits
	* fix MooArray instances so that they pass a destroy_t function (how can you get it to work with delete??)

	* what is the MooAction class used for?  Make code use MooObject instead where possible (like in MooThing::get_action)

	* make it so that there is always a code frame, from the very start, and everything uses it, including builtins.  If a builtin
	  needs to call another method, it must do so indirectly using the frame.  The frame could either just always be passed, or else
	  passed as a variable stored in the environment.
	* add return/return-from (how does lisp do it?) for breaking out of loops or returning early
	* add nested hash tables, and add caching (so a reference is always made in the local env to a value that was looked up in a
	  distant env (this only works, really, if no writing to parent env's is allowed))
	* we could actually prevent an attempt to add the same method to 2 objects by looking at the number of references
	* should you have private environments that are skipped when doing nested lookups?
	* should you store a pointer to frame in the env?  this might have a lot of problems 
	* should you modify the writing system to write each MooThing into it's own file?  Or to just write it all together but forget
	  about the idea of seperate world systems, and the whole /path system of referencing

	* should the NULL passed to evaluate() in some cases be changed? (only in MooThing::do_action)
	* you could probably replace the whole parse_args bit with a few parameter format options, or it could even be specific to
	  builtin actions, such that the param checks/parsing all happens during the MooBuiltin::evaluate() function
	* remove the channel arg from parse_args() at the very least, if not remove the whole function
	* convert notify() that takes args to take env or something else instead
	* consolidate/move the moo_global_table from thing into the code's global table?
	* get rid of MooBultin's MooAction parameter??
	* rename everything to do with action to 'method'

	* add permissions checks to access and evaluate functions
	* how will methods work, in terms of getting the object they were called on?
	* how will user/channel be set/passed around and so on?  Could we even have certain I/O functions that you call and which then
	  forward the call on to the appropriate user/channel stuff??  MooTask might be an appropriate place for that.



	* add a <script> tag or something to the world loader which allows you to specify an external file which contains source code
	  such that it is loaded by an appropriate loader. <script type="lua" ref="scripts/core.lua"/>
	* data/maps/ is not a good dir name.  Perhaps it should be data/objs/ or soemthing like that (or data/worlds/)
	* make MooObjectHash and MooObjectTree, and convert MooThing to use them for prop and action tables (and their automagic saving
	  functionality)
	* should you try to replace all make_string references with std::string stuff? Should all strings be one or the other?
	* make sure it is not possible for a user to change his/her last_location value, logout, log back in, and get teleported to
	  some place they aren't supposed to be
	* can you convert init/release functions to be constructor/destructor of a singleton class?
	* make a clone() function that copies all properties and actions (such that they can be overridden without changing??).
	* make a do_action which does not catch exceptions, so that they can be passed on.  What will we use to differentiate the 2 types
	  of functions?  How will we differentiate in general?
	* make it so that builtin functions have all sorts of things built in (when the functions are registered with the
	  central table, it stores the records as MooBuiltin * objects), like the default name, the expected params, etc.  Then
	  you can specify an action with <action type="builtin">basics_look</action>. 
	* go through all read/write functions and make sure everything is covered and everything works (MooThing, MooWorld, MooUser, etc)
	* could you make a special channel that forwards all text to another mud via a telnet-like connection, and returns all data as
	  notifies to that user
	* should actions that are called internally have a special name designator (either from code or from the command line).  Should
	  functions intended for internal use be inaccessible from the command line?

	* add stuff for this new global table and integrate it better
	* add object recycle (delete) function and command
	* make the accept() function of non-room objects say something (to user and everyone else) like "$user tries to climb into $thing
	  but fails miserably"
	* modify attribute/colour formatting to use a stack of attribs, and to revert when closed tag is found
	* should you make a macro or something to simplying notifying to the user from an action?
	* implement variable argument *matching* function
	* fix thing->command() (object/target do_actions are disabled atm)
	* add permissions checking functions of some kind to all applicable locations
	* add support for notices from clients to other clients
	* add a 'register' and 'login' commands to basics
	* implement client quit in the channels
	* perhaps add "TheRealm" to any channel users list (names)

	* everything should use actions that return a value rather than direct values for information, so that the action can do
	  processing and adapt its output
	* make a pet kitty cat object as a scripting test
	* make a mobile-equivallent of logarithm
	* make some room games for testing, like trivia, maybe munchkin if you are ambitious, or go fish??
	* add irc server-to-client pinging & connection timeouts
	* fill in all other IRC message processing

    Old Stuff:
	* should you change the position of the caller argument in all of the do_action util functions?

	* make @destroy command
	* add a @write_world command
	* add a @get command for returning the raw property values
	* add functions to lua for util_expand_ref stuff
	* should you make the announce action add a "\n" before each output to the user in order to prevent
	  interrupting the current line being typed instead of putting it in all the places that generate
	  output sent to the announce action?
	* make the code use the "title" property instead of the "name" property for displaying the name
	  of an object
	* change the name of tell_view

	* parser format:   command[/modifier] [-flags] [object [preposition indirect-object]

	* the biggest problem with any parsing format will be for the get <object> from <container> command
	  specifically.  The object must be searched for in the container which is not normally searched
	  as a location for the direct object.  Either object searching can include an object specified in
	  the command, or wehre to search can be specified in the action definition, or just a string can
	  be passed and it will be up to the action code to resolve the string.
	* can you use regexes to do parsing? or would that be waaaay too slow and painful?
	* clean up/add parsing functions to lua to make it easy to parse the args
	* make object name matching match part of a word like if the name is "The Thing" somehow match "thing"
	* make sdm_interpreter_find_thing() use the aliases of an object for matching as well as doing partial
	  matching of the string given.

	* should a list use the object itself to hold the next pointer (part of object) which means that
	  exact object can only be in one list at a time?
	* should objects have a pointer to the list they are contained in so that they can be removed from
	  that list when they are destroyed?

	* fix the 'get' action to actually use the second arg properly
	* how do you prevent a user from directly calling actions that he shouldn't call directly on the
	  command line
	* add command shortcuts like lambdamoo's \" for say and : for emote

	* have the telnet module more closely control the printing of the command prompt such that after
	  output has been generated, a command prompt in printed (will be hard to know when output is over).
	  You could have a special check in the main server loop that checks a flag set when output has been
	  sent and if output was sent, print the command prompt?? (complex and lots of border cases)

	* add a jump_ok property and maybe even a distant_look_ok or something that allows looking at an
	  object without being nearby
	* perhaps you can add colour theming through the user properties and the expand string notify by
	  having <$caller.error> and so on type tags in string being printed using notify
	* make the look_self action tailor the description to the type of object it is describing (ie. don't
	  list the items a person is carrying)
	* how do you decide what things to print in the list of contents since you don't want to print all
	  objects such as exits and stuff (perhaps by calling a function on the object that makes it describe
	  itself)
	* make functions for setting the name and description of an object
	* add actions for manipulating things: get, give, drop, inventory, etc
	* convert all hardcoded id references to named references (such as the starting room in user and form)
	* make an "exits" command that prints the list of obvious exits and their descriptions
	* print the equipment, weapons, armour, etc seperately and/or provide commands that print only
	  one type
	* try to remove the direct references to sdm_user the the args of the processor virtual functions
	* try to make thing not directly reference user and world in it's load/save functions

	* should you add a flag to objects somewhere that specifies that the object should be written to a
	  seperate file (sdm_user) for checking when writing a container instead of a hardcoded check for user?
	* make the lua error print to the user (or at least optionally)

	* have an etc/telnet.xml file with <server> entries to run servers and the data on what registration
	  restrictions and objects to use will be there
	* should the connect/disconnect functions call an action on the object to allow for extra stuff to
	  be done?

Structural Issues:

	* i don't like the sdm_moveto function in that the action it calls must guess what the hell is
	  supposed to be happening based on what the arguments are.  For example, if i steal an object from
	  another user, it would be moveto(me, obj, me, NULL) but that looks exactly like picking up an
	  object or getting an object out of a container.  It's only because the container is not owned by
	  me that it's stealing.
	* can/should there be a way of doing an overridden action? (knowingly passing an object to an action
	  on a parent of that object to avoid an overloaded action? (to change it's overt behaviour without
	  reimplementing the functionality) (eg. override the say command to prevent talking while asleep)
	* should you change format codes to something like bbcode ( [red] instead of <red> )

    Output Formatting/Interfaces:
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).

Gerenal:

	* write and implement details on converting input received (in the server core format document)
	* tidy up the xml formatting in telnet and add theme tags (tags that indirectly refer to format)

	* make the login track invalid attempts and terminate the connection after a while (for all interfaces?)
	* add a way to automatically timeout login attempts (for telnet)
	* implement proper handling of telnet commands

	* make it possible for the command prompt to display info (call a function to generate it)

Features:

	* focus on chatting/social rather than game (for now)
	* make the server multithreaded.  You'd need some kind of semaphore lock on the objects so that calling
	  an action locks the object
	* multiple scripting languages: sdrl, lua (Is this even worth it anymore?)
	* python would be like room.action("look") to run an action, room.get("desc") to get property, etc
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #realm or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #realm channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface
	* include a fully functional editor/construction kit, which could even save the word automatically
	* make a seperate program that can generate a visualization of some kind of parts of the database, so that you can make maps

	* you could have a protocol that would allow object based RPC (via xmlrpc or a custom system or something) such that you could
	  implement both a client connection (calling actions (methods) on the user thing object through which everything can be done)
	  or controlling other objects allowing out of process extensions
	* in future, we could make a client (klunky), services (is this even possible), or server based IRC interface.  If it requires
	  (or would be easier to use) some existing code (like perhaps even writing a module for anope), you could easily just have it
	  act as an RPC client to the Moo Server over a socket (which we have yet to figure out)
	* what are the merits of a disk-based thing database rather than having all objects in memory?  If we were to add this, it
	  could probably be done transparently to the existing code

	* you could have extra data in the xml map file for things like sound, graphics, etc. and have a
	  special client or clients (sdmc, written in C, maybe a flash/web based interface).  These clients
	  could connect using a different interface and processor but get into the same core and interact in
	  the same sort of way.  (interface -> processor -*-> API, where -*-> means many different calls).
	  The client could maybe have predownloaded the data or could pre-cache it automagically from the
	  server.  Maybe map data would be on the fly and tiles and sounds are precached.
	* Each room could have it's own tiled map and going out a room "exit" like a door would be the same
	  as in the text game, transporting you to another room.  Things would still operate on a room
	  basis, so fighting and picking up items and stuff doesn't change based on where you are in the
	  tiled room.  Maybe you might not even be able to move (such as if it's a web-based one).  On the
	  bottom part of the screen would be a console that prints a lot of the text that you would normally
	  see.

