
	* sdrl has one shared machine
	* read_action makes an expr and stores it with an do_action function.  The do action function makes a
	  new environment, assigns "user", "this", "args" as variables where user and this are special
	  sdm object types and args is jsut a string. It then evals the expr
	* make a sdrl unparser (perhaps as part of SDRL itself)

	* have a linked list of processors in the user object with a pointer to the currently active one
	  and read/write the processor's data to the user file.  There should be a function for code to select
	  or create a new processor in the user as well as remove one.  The "next" pointer wolud be in proce..
	* the owner data file tag might cause problems because the object might be created by the container
	  but the owner tag might override that.  You have to make sure this ins't an issue

	* add colour tag parsing to telnet
	* implement the writing of actions in module/basic
	* add a status message that prints login attempts and logins and logouts
	* add a way to write CDATA to data.c
	* make various commands use the extra text passed in a command as a text modifier.  For example you
	  could say "give apple to trans carefully" and it will interpret the command like normal and the
	  'carefully' at the end would be tacked onto the output as "Wizard gives an apple to trans carefully"
	* add support for up/down (?) or should that only be the client's responsability?
	* add command shortcuts like lambdamoo's \" for say and : for emote
	* add a system of relative object shortcut names specified in commands like "me" will refer to the
	  user object and "here" refers to the room the user is currently in
	* make system things configurable through xml files

	* make a central list of object types added somehow and searchable by both name and type pointer which
	  can possibly be used for loading data but it might get pretty messy

	* implement all of the read_data functions
	* make container write certain types of objects to different files (like users and mobiles should
	  probably go in their own files
	* implement all of the write_data functions
	* make the container_find() function continue searching for more complete matches

	* make telnet (and other interfaces) convert <format> tags into colours based on themes such that
	  output would instead be <title>The Room</title> for example and title would be looked up in a colour
	  table and blue, say, would be outputted as the colour for title but that assignment could be changed.
	  You could also set a mode that allows the xml itself to be transmitted raw so that the other end
	  can use it for displaying with a special client able to recognize it

	* add the ability for telnet to read user specific configuration data from the user file
	* read and write the processora object from the user data file
	* make a character creation game object thingie that telnet can call to generate your character
	* implement proper handling of telnet commands

	* make the login track invalid attempts and terminate the connection after a while
	* add a way to automatically timeout login attempts
	* accept a "-d" command line arg and fork to a daemon process
	* make the login object use/store multiple methods of authentication (primarily for other interfaces)

	* add public git respository to catalogue after changing this working directory to sdm/
	* make it easy (through data.c) to have multiple "data modules" (only needed for maps and stuff)
	* make it possible for the command prompt to display info (call a function to generate it)

Refactoring:

	* change the member "owner" of thing to something else
	* should you change interface/ to interfaces/

Structural Issues:

	* how can you determine what xml element name to use for property objects without having to handle
	  each object type seperatly?
	* when you attempt to perform an action on the user and user's owner before the object, you run
	  into issues such as "look" being defined for the location and an object but because you look up
	  the location first, you do the location's look action and not the object's look action even if
	  the object is specified in the look command.  One solution is of course to force these objects to
	  have different commands for "look".  Another option is to be able to specify parameters that an
	  action will accept so only if there are no args will the "look" in location be executed
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?

	* is the way we call the callbacks in sdm_interface_select right in that we call each callback
	  once *for each condition* so the same function is called with the same interface for each
	  condition that it's registered for.  How does the callback tell the difference?  should there
	  really be 3 callbacks?  Or should you only be able to handle one condition? or should the callback
	  only be called once and it's up to the handling routine to check each descriptor to see which one
	  is ready?  Isn't there a function called poll that can be used instead of select in those situations?

	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).

Features:

	* multiple scripting languages: sdrl, lua
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #world or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #world channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface

