
    Large Ideas/Features:
	* make irc client-like interface, c/w full line editing, status bar stuff maybe, smart autocomplete, and
	  make it so that what you type is said directly, but a special command prefix means it's a command (/get)
	* focus on chatting/social rather than game (for now)
	* make it possible, one way or another, for bots (external programs) to connect and act like players (npcs)
	* include a fully functional editor/construction kit, which could even save the word automatically
	* you could have a protocol that would allow object based RPC (via xmlrpc or a custom system or something) such that you could
	  implement both a client connection (calling actions (methods) on the user thing object through which everything can be done)
	  or controlling other objects allowing out of process extensions
	* in future, we could make a client (klunky), services (is this even possible), or server based IRC interface.  If it requires
	  (or would be easier to use) some existing code (like perhaps even writing a module for anope), you could easily just have it
	  act as an RPC client to the Moo Server over a socket (which we have yet to figure out)
	* for lua, why can't you just make a bunch of special "types" which are just tables with functions and a pointer to the raw
	  internal data value (like MooThing *, or whatever) and the functions are c functions that get the raw pointer and do raw
	  manipulations on it

    Discussion:

	* the editor task could be implemented via whatever protocol by just passing all the code to the client, allowing it to
	  locally edit it, and then passing it back.  Even if an online (server-side) editor is used, it could store all the code in
	  a buffer, edit it, and then pass it all back when done.  How will editing work through IRC?
	* should MooInterface use a MooTask as the handler, or should it make a custom handler class like MooTimer does?

	* add a bitflag to MooThing to indicate that the thing is locked and cannot be replace or deleted.  This could then be set
	  to indicate that a direct pointer is being used.  MooUser could set this bit for the cryolocker to protect it.
	* perhaps you could add a lock/unlock method pair to MooObject or MooThing such that you pass it a pointer to the user (or
	  object, or task, or something) that is trying to lock an object.  If you are using multithreading, it will use a semaphore
	  or else just a bit and if successfully lock, will save the pointer passed to it.  That pointer can then be used to determine
	  who is performing an operation on that object (for permission checking) while at the same time allowing multithreading
	* think about multithreading possibilities

	* when using the 'go' command, or otherwise trying to teleport directly to a specific room, there should be a check such that
	  only wizards (or owners of the room??) can do this for most room except a few with a special flag that allows it

	* should an action be directly passed the object pointer on which the action exists or should it get the pointer to the object
	  on which the action was called (which m_thing would be set to in the args anyways)?
	* we should add various checky things to MooAction like the number of args that are acceptable and stuff so that we can do
	  checking
	* could you perhaps add some objects to the properties list as 'constants' so that you could store either the pointer to the
	  MooObject value, or to the value embedded in the object in MooThing itself so that it is easy for C stuff to access directly
	  but is also accessible as a property and no effort is needed to keep both values consistent (since they are the same).
	  Perhaps you could also just say to fuck with it and just always access it as a property (and use accessor functions to make it
	  easier to manipulate in C) (???)
	* should some properties have a fixed type such that a value of another type cannot be assigned and when reading, don't check type?
	* you could have a function like user->tell(thing, str) or something that looks up the action and calls it (which would most
	  likely be directed to user->print() but would allow it to be reprogrammed)
	* should there be a function (in builtins) that creates either a special root object (for various types, like room, channel, etc)
	  with props and actions set to appropriate default values, or possibly a function which creates an equally appropriate
	  subobject which inherits from the core object?

	* by make a subclass of both user and task, which can be used in place of both (task is already ok for this, but user would
	  need some more virtual functions), it would be possible to easily implement an RCP break, such all code can be used to make
	  combinations of either the server or client side of the connection, with minimal effort.  ie. function calls to task, to
	  write to user, can be redirected over an RPC connection, and come out the other side, just as the other side of the function
	  call.  Therefore, we need to work on the RPC system, the IRC system, and the telnet system =P
	* the 2 other IRC interface methods (client connected as TheRealm, privmsgs are directly interpreted as commands, output is
	  directly printed, exactly the same as it would appear on telnet (more or less), -OR- server based, either the same as the
	  client (but with services-like permissions), or ... actually the method with #realm wont work with multiple IRC servers,
	  since all users associated with that channel will receive the same text, so everyone will recieve everyone else's private
	  traffic.  #realm could be use for only talking, with notices being sent for status messages, but that would get really
	  annoying since the notices might appear in other windows (dependant on client).  However, a system of #324 numeric channels
	  or something like that would still be possible (channels could be +si or something, so that you can only join if you are
	  forcejoin'd by TheRealm.)
	* the #<numeric> channels idea would require the object number corresponding to the intended target.  If it's the user object,
	  it's sent to the user directly as a privmsg (whisper would be like this).  If it's something else (like a room) then it's sent
	  to the user as coming from that channel.
	* pseudoserver works fine with the new talk() function for other channel data, but for the realm channel, there is still an issue
	  with how the data sent to the function is formatted.  If it is formatted the same as would be used in the telnet or irc client
	  methods, then the data would have to be sent from TheRealm user, or to #realm channel, as if it were direct status messages.
	  (eg. $timestamp <TheRealm> chanser says, "You're weird"  \  <TheRealm> Rabbit whispers, "Hey man"  \  <TheRealm> Rabbit picks
	  up a short sword from the ground.)  It would look kind of weird but it gets the job done.  This would require only the
	  formatted string text to be sent to the function.  Alternately, if you want to make it appear like 
	  eg. $timestamp <chanser> You're weird  \  PM->$timestamp <Rabbit> Hey man  \  * Rabbit picks up a short sword from the ground.
	  This would require the action name called (say, whisper, etc) and the user object who says or does the thing.  If you got
	  (rabbit, "says", "Hey man"), it would print that as a privmsg (channel speech vs pm could be determined with a channel param.
	  see below note for details).  If you needed to print something like "You see a strange goat here", you could either be
	  bold and send (you, "see" "a strange goat here"), or you could be less bold and say (TheRealm, NULL, "You see a strange goat
	  here") which would appear as $timestamp <TheRealm> *** You see a strange goat here
	* Either of the pseudoserv function solutions mentioned above will need a MooThing *channel parameter to also be compatible with
	  the #<numeric> method.
	* also, how will join/quit and channel membership be stored?  It could be a list in properties of user references.  How
	  would the list be maintained though
	* there is yet another option for everything: when someone talks in the realm (in a room, as normal speech) then the data
	  is sent by calling talk(root_world, user, "Hey") and when displaying anything else (like actions, etc) it is sent
	  as print(thing, "You see a goose"), where thing is the room or whatever that it originates from (for use by the #<numeric>
	  method).  talk() could simply check for root_world and print it however it should be in the root world ("$user.name says Hey"
	  if it's a client/telnet, or :$user.name PRIVMSG $channel.name :Hey for IRC.  You could also handle the ':' emote in the same
	  way.
	* #<numeric> doesn't work with the number being the room id.  It only works if the channel is a special custom channel for
	  that user.  This would not require the forcejoin method.  It doesn't work because again, you have no way to print status
	  messages, just like #realm in a multiserver irc system.  With this in mind, the "realm" messages don't need a channel
	  identifier, since the data always goes to the same user-specific channel
	* we could have print(thing, "text") and if thing is NULL, then it's just a direct status message (to come from TheRealm) and
	  if user is something, then it's identical to the talk() function (where direct text is "say" data, and ':' text is "emote"
	  data, for that user).  Since we don't need the channel id, we might even be able to use talk() with channel set to NULL
	  being equivallent to print() (thus unifying back into a single function with multiplexing based on params)
	* should all everything (actions, all code that prints) call do_action on user, which would call a function which calls the
	  task's API, rather than directly calling user->print() or whatever?  This would all redirection of the I/O calls
	* how will a task notify objects of a join/leave/quit event?  How will an object do the same to tasks?  I actually don't think
	  we need task to notify objects, since everything will be done via actions on objects
	* We can make use of the single unified task notify() function if we want since the interface will be hidden by methods on
	  MooUser (i think).  We will still have user->print, and perhaps user->talk which then calls methods on task.

	* for channel management, it is possible to have user call an action on itself when it connects/disconnects, which can then call
	  the channel central object (which has a list of all channels) and it then calls actions on each channel to notify it of the
	  user's new status, which causes it to remove the user from the list of users and send disconnect notices to each user in
	  that channel.  Ok, here's a new problem.  How do you notify the clients of user connect/disconnect/join/part/etc??

	* we could have a number of methods on MooThing which directly call actions (like notify(), announce(), etc)
	* we could have queued actions (or a special param or something passed to do_action) such that the action data can be copied
	  and placed in a queue to be evaluated later (namely when the object is unlocked, when doing multithreading and stuff).

	* at some point we should rethink about MooArgs, and the ability to pass multiple parameters, specifically, being able to
	  have an action like notify(channel, user, type_num, string) (a static array of MooObjects??)

	* make a clone() function that copies all properties and actions (such that they can be overridden without changing??).

	* can array (and hash and tree, and also list) all be MooObject subclasses so that they can be ... treated like
	  MooObjects.  I'm not entirely sure of the point of this and so on. (it would allow these to be MooThing properties, so
	  that they can be read from/written to data files automatically and stuff.  It shouldn't actually effect the size or
	  behaviour of the table much.

	* check out Smaug's system/socials.dat.  It has various premade commands for interaction which don't actually do anything
	  other than print various messages to various people but would make a great addition.  Find out what each line is for
	  (it's able to print different messages to different people/objects) and also what variables are available for expansion in
	  the actual strings.

    Covnersion TODO:
	* add a <script> tag or something to the world loader which allows you to specify an external file which contains source code
	  such that it is loaded by an appropriate loader. <script type="lua" ref="scripts/core.lua"/>
	* make an internal language of some kind
	* go through all read/write functions and make sure everything is covered and everything works (MooThing, MooWorld, MooUser, etc)

	* modify the handle() function to do something like close the interface if an error occurs?
	* should you try to replace all make_string references with std::string stuff? Should all strings be one or the other?

	* sort out and make better use of exceptions (in do_action in particular).  You can't catch a segfault but you can throw
	  exceptions when certain functions would otherwise return a NULL.  You could alternativley have an TRY() macro or something
	  which runs the function and throws -1 if it returns a value less than 0 (what about NULL...  NULLCHK() )
	* make it so that builtin functions have all sorts of things built in (when the functions are registered with the
	  central table, it stores the records as MooBuiltin * objects), like the default name, the expected params, etc.  Then
	  you can specify an action with <action type="builtin">basics_look</action>. 
	* think about adding param checks to do_action, (lambdamoo uses this, any, none as values for each of 3 parameters, object,
	  preposition, target)
	* add a 'register' and 'login' commands to basics
	* should you/could you just have a fixed array of like 6 elements of MooObject or something as arguments in MooArgs (which would
	  replace object and target perhaps).  That would allow better parameter passing
	* finish the guest user creation function
	* create 'init' actions for user, room, etc objects
	* should you convert some functions to using a moo_id_t rather than a thing pointer?  It would require an extra lookup in
	  exchange for allowing error checking (NULL checks in particular) to be moved to other functions

	* actions permissions (lambdamoo 'rwxd') property permissions??  SUID bit?
	* we are thinking about permissions as ints directly in objects...  Lambda treats objects like dirs and prop/verbs as files,
	  permissions-wise.
	* fill in owner and permissions values in the existing XML files
	* add various permissions flags and their meaning
	* add permissions checking functions of some kind

	* data/maps/ is not a good dir name.  Perhaps it should be data/objs/ or soemthing like that (or data/worlds/)

	* add irc server-to-client pinging & connection timeouts
	* fill in all other IRC message processing





    Old Stuff:
	* make sdm able to use python and SDRL (and possibly lua) simultaneously but there is no need to
	  make it capable of supporting more than this.  Making it capable of *only* python would not be
	  terrible either because that's likely the only language worth using.
	* python would be like room.action("look") to run an action, room.get("desc") to get property, etc
	* the downside of python is it's manditory whitespace; perl would be nicer

	* should you change the position of the caller argument in all of the do_action util functions?
	* target in action_args should be named something else

	* make @destroy command
	* add a @write_world command
	* add a @get command for returning the raw property values
	* add functions to lua for util_expand_ref stuff
	* should you make the announce action add a "\n" before each output to the user in order to prevent
	  interrupting the current line being typed instead of putting it in all the places that generate
	  output sent to the announce action?
	* make the code use the "title" property instead of the "name" property for displaying the name
	  of an object
	* change the name of tell_view

	* parser format:   command[/modifier] [-flags] [object [preposition indirect-object]

	* the biggest problem with any parsing format will be for the get <object> from <container> command
	  specifically.  The object must be searched for in the container which is not normally searched
	  as a location for the direct object.  Either object searching can include an object specified in
	  the command, or wehre to search can be specified in the action definition, or just a string can
	  be passed and it will be up to the action code to resolve the string.
	* one alternative is to send an array of object pointers to the action using an args string or
	  or something but this means you have allocate everything and then deal with the complexity in
	  the actions themselves still
	* a thing you really should think about but that is hard to know the effects since you don't really
	  do too much of it now is calling actions from within other actions without using a string that gets
	  parsed.  Whatever parsing solution must somehow work with both methods of invocation but we don't
	  have a clear idea of when the 2 different methods would be used nor how we'll handling limiting
	  what actions can be called from the command line.  It is possible that we could end up just
	  having actions that are always called from command line and actions always called from other actions
	* either way i would very much be in favour of a central parser and argument checker which would
	  make the commands themselves simpler not having to do all the parsing themselves
	* can you use regexes to do parsing? or would that be waaaay too slow and painful?
	* either make the parse_args function handle more arg cases or make the other functions easier
	  to use.  Make parse_args work properly/nicely with the get/put/drop commands?
	* clean up/add parsing functions to lua to make it easy to parse the args
	* i don't like the parsing functions available
	* i don't like the way commands are parsed particularily the fact tha firstly, you can't specify a
	  partial name and secondly that things like "get the thing" doesn't work at all (and doesn't even
	  seem to print a proper error)
	* make object name matching match part of a word like if the name is "The Thing" somehow match "thing"
	* make sdm_interpreter_find_thing() use the aliases of an object for matching as well as doing partial
	  matching of the string given.
	* can you make object lookup in the interpreter try to match the whole command line and whatever
	  matches the best is used as the object name and the rest is passed as the args string?

	* should a list use the object itself to hold the next pointer (part of object) which means that
	  exact object can only be in one list at a time?
	* should objects have a pointer to the list they are contained in so that they can be removed from
	  that list when they are destroyed?

	* fix the 'get' action to actually use the second arg properly
	* how do you prevent a user from directly calling actions that he shouldn't call directly on the
	  command line
	* implement a permissions system for object modification
	* add command shortcuts like lambdamoo's \" for say and : for emote
	* add the ability for sdm_util_resolve_reference() to call actions on objects and to handle multiple
	  references such as $thing.location.name and such

	* have the telnet module more closely control the printing of the command prompt such that after
	  output has been generated, a command prompt in printed (will be hard to know when output is over).
	  You could have a special check in the main server loop that checks a flag set when output has been
	  sent and if output was sent, print the command prompt?? (complex and lots of border cases)
	* we'll have to add reference counting of objects at some point

	* add a jump_ok property and maybe even a distant_look_ok or something that allows looking at an
	  object without being nearby
	* perhaps you can add colour theming through the user properties and the expand string notify by
	  having <$caller.error> and so on type tags in string being printed using notify
	* make the look_self action tailor the description to the type of object it is describing (ie. don't
	  list the items a person is carrying)
	* how do you decide what things to print in the list of contents since you don't want to print all
	  objects such as exits and stuff (perhaps by calling a function on the object that makes it describe
	  itself)
	* make functions for setting the name and description of an object
	* add actions for manipulating things: get, give, drop, inventory, etc
	* convert all hardcoded id references to named references (such as the starting room in user and form)
	* make an "exits" command that prints the list of obvious exits and their descriptions
	* print the equipment, weapons, armour, etc seperately and/or provide commands that print only
	  one type
	* try to remove the direct references to sdm_user the the args of the processor virtual functions
	* try to make thing not directly reference user and world in it's load/save functions

	* should you add a flag to objects somewhere that specifies that the object should be written to a
	  seperate file (sdm_user) for checking when writing a container instead of a hardcoded check for user?
	* make the lua error print to the user (or at least optionally)

	* have an etc/telnet.xml file with <server> entries to run servers and the data on what registration
	  restrictions and objects to use will be there
	* should the connect/disconnect functions call an action on the object to allow for extra stuff to
	  be done?

Refactoring:

	* should "this" (thing) be passed seperately like it is now or just using the one in the args?
	* should you not use the ARGS macros?
	* make all types use init functions of the form "init_sdm_<name>_type" or else convert string and
	  number to *not* use that form

Structural Issues:

	* i don't like the sdm_moveto function in that the action it calls must guess what the hell is
	  supposed to be happening based on what the arguments are.  For example, if i steal an object from
	  another user, it would be moveto(me, obj, me, NULL) but that looks exactly like picking up an
	  object or getting an object out of a container.  It's only because the container is not owned by
	  me that it's stealing.
	* can/should there be a way of doing an overridden action? (knowingly passing an object to an action
	  on a parent of that object to avoid an overloaded action? (to change it's overt behaviour without
	  reimplementing the functionality) (eg. override the say command to prevent talking while asleep)
	* should you change format codes to something like bbcode ( [red] instead of <red> )

	* how do you get the thing to record information in when using a form?
	* how would you make different subselections in a form based on previous input (only ask a certain
	  question if the answer to a previous question was a certain answer)?
	* in lua, how do you tell if the result of an action is a number or a thing id?

	* should it be assumed that an interface subclass will always be used for a different type of
	  connection (like the telnet class that inherits from tcp instead of using a tcp object seperately)
	  in which case we can instead of using callback with a stored pointer, either just have the function
	  and passed the condition that occurred and the interface pointer or even specifically a virtual
	  function of the same type common for the whole class.  The extra data associated with that class
	  (like the user object for a telnet connection) can be stored in the subclass.  Having a single
	  handler per class would mean you would need to multiplex functions as they are now or else have
	  another function pointer that you call in telnet for doing the whole login process.  If we still
	  have the callback per object but just no ptr value, it just wouldn't be as easy to use an interface
	  for "some other" connection but we shouldn't have a need for that and if we do, we can make a
	  general subclass if we really need.
	* is the way we call the callbacks in sdm_interface_select right in that we call each callback
	  once *for each condition* so the same function is called with the same interface for each
	  condition that it's registered for.  How does the callback tell the difference?  should there
	  really be 3 callbacks?  Or should you only be able to handle one condition? or should the callback
	  only be called once and it's up to the handling routine to check each descriptor to see which one
	  is ready?  Isn't there a function called poll that can be used instead of select in those situations?

    Output Formatting/Interfaces:
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).
	* think about the processor system.  it might be good to seperate it such that if a raw xml client
	  was developed, it should be able to communicate directly with the code that handles telnet clients
	  directly ontop of the code that accepts the xml client essentially

Gerenal:

	* write and implement details on converting input received (in the server core format document)
	* tidy up the xml formatting in telnet and add theme tags (tags that indirectly refer to format)
	* add the ability for telnet to read user specific configuration data from the user data file
	* implement proper handling of telnet commands

	* make the login track invalid attempts and terminate the connection after a while
	* add a way to automatically timeout login attempts
	* make the login object use/store multiple methods of authentication (primarily for other interfaces)

	* make build.pl only use the cflags for certain modules as needed instead of all modules being
	  compiled with the flags for all embedded languages for example
	* make it easy (through data.c) to have multiple "data modules" (only needed for maps and stuff)
	* make it possible for the command prompt to display info (call a function to generate it)

	* add a release function to SDRL to release the expr when the sdrl action object is destroyed
	* make a proper (if ) and any other handy forms to make it easy to program
	* make a sdrl unparser (perhaps as part of SDRL itself)
	* make functions for controlling the properties of sdm_things
	* make functions for moving objects between containers

Features:

	* make the server multithreaded.  Perhaps "processors" (input handlers) could be threads.  You'd
	  need some kind of semaphore lock on the objects so that calling an action locks the object
	* multiple scripting languages: sdrl, lua
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #world or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #world channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface

	* you could have extra data in the xml map file for things like sound, graphics, etc. and have a
	  special client or clients (sdmc, written in C, maybe a flash/web based interface).  These clients
	  could connect using a different interface and processor but get into the same core and interact in
	  the same sort of way.  (interface -> processor -*-> API, where -*-> means many different calls).
	  The client could maybe have predownloaded the data or could pre-cache it automagically from the
	  server.  Maybe map data would be on the fly and tiles and sounds are precached.
	* Each room could have it's own tiled map and going out a room "exit" like a door would be the same
	  as in the text game, transporting you to another room.  Things would still operate on a room
	  basis, so fighting and picking up items and stuff doesn't change based on where you are in the
	  tiled room.  Maybe you might not even be able to move (such as if it's a web-based one).  On the
	  bottom part of the screen would be a console that prints a lot of the text that you would normally
	  see.

