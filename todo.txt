
    New Focus:
	* make irc client-like interface, c/w full line editing, status bar stuff maybe, smart autocomplete, and
	  make it so that what you type is said directly, but a special command prefix means it's a command (/get)
	* make it able/focus on chatting as if it's just like an irc channel like #philosophy, but it has objects which
	  the chatters can interact with and with eachother with actual effect, play games, etc
	* possibly make an IRC-like protocol (maybe even IRC protocol itself so that you can use irc clients to connect)
	* make it possible, one way or another, for bots (external programs) to connect and act like players (npcs)
	* focus on the objects and object interaction rather than rooms, maps, or a story
	* include a fully functional editor/construction kit, which could even save the word automatically

	* can array (and hash and tree, and also list) all be MooObject subclasses so that they can be ... treated like
	  MooObjects.  I'm not entirely sure of the point of this and so on. (it would allow these to be MooThing properties, so
	  that they can be read from/written to data files automatically and stuff.  It shouldn't actually effect the size or
	  behaviour of the table much.

	* the user object should have actions called on itself most of the time, so that the user can reprogram his/her
	  own object to customize and extend their own interface and command set
	* there must be a process table and any time a process does stuff, it is set to the current process.  Any processes
	  that are created by that process will use that as their parent process.  Each interface will have a reference to the
	  process that owns it.
	* is it possible to have something like sshd automatically run a certain program upon connection (to a specific port) such
	  that this program either directly transfers data to the MOO (running in a seperate process) or handles the basic I/O and
	  such, communicating with the MOO core via a raw protocol of some kind?  This would move most of the communications code
	  out of the core and allow you to use sshd of course (i don't think this is possible because sshd is too specfic for shells)
	* the editor process could be implemented via whatever protocol by just passing all the code to the client, allowing it to
	  locally edit it, and then passing it back.  Even if an online (server-side) editor is used, it could store all the code in
	  a buffer, edit it, and then pass it all back when done.

	* you could have a protocol that would allow object based RPC (via xmsrpc or a custom system or something) such that you could
	  implement both a client connection (calling actions (methods) on the user thing object through which everything can be done)
	  or controlling other objects allowing out of process extensions (object servers and stuff written in other languages, allowing
	  language support like perl and stuff (???)).
	* for this to work, you need a permissions system (which you need anyways) so that a connection cannot do an action on an
	  object it does not have permissions on.
	* instead of using MooTask in interface as the object you call in order to handle I/O, maybe you could make a special abstract
	  class and use multiple inheritence so that any object (not just tasks) can be called in response to I/O.  The same would
	  then go for MooTimer
	* in MooUser, it should store the pointer to the cryolocker but how would it create or load it?  The init happens before the
	  world is loaded, so we can't just look up the object.  We could create one though, it just wont have any settings of any
	  kind.
	* add a bitflag to MooThing to indicate that the thing is locked and cannot be replace or deleted.  This could then be set
	  to indicate that a direct pointer is being used.  MooUser could set this bit for the cryolocker to protect it.
	* for lua, why can't you just make a bunch of special "types" which are just tables with functions and a pointer to the raw
	  internal data value (like MooThing *, or whatever) and the functions are c functions that get the raw pointer and do raw
	  manipulations on it
	* on a totally unrelated note straight out of the blue, should you add a pointer to MooAction which points to the owning thing
	  (which would be the direct parent and not a child which is calling it).  I don't know what purpose this would serve but it
	  might be needed at some point
	* there needs to be a global channel system for IRC to work
	* when using the 'go' command, or otherwise trying to teleport directly to a specific room, there should be a check such that
	  only wizards (or owners of the room??) can do this for most room except a few with a special flag that allows it

	* think about multithreading possibilities

	* should an action be directly passed the object pointer on which the action exists or should it get the pointer to the object
	  on which the action was called (which m_thing would be set to in the args anyways)?
	* we should add various checky things to MooAction like the number of args that are acceptable and stuff so that we can do
	  checking
	* data sent back to the user (output to be printed) should be accompanied by one or more Things (eg. the "channel" object
	  and the user or object where the message originated from).  So if someone says somehting in a chat channel, it gets sent
	  to that Thing, which then sends it out to each of the other users.  Or if you interact with an object (if you 'examine' an
	  object), it could send the response back along with the object and the room you are both in.
	* could you perhaps add some objects to the properties list as 'constants' so that you could store either the pointer to the
	  MooObject value, or to the value embedded in the object in MooThing itself so that it is easy for C stuff to access directly
	  but is also accessible as a property and no effort is needed to keep both values consistent (since they are the same).
	  Perhaps you could also just say to fuck with it and just always access it as a property (and use accessor functions to make it
	  easier to manipulate in C) (???)

    Covnersion TODO:
	* sort out and make better use of exceptions (in do_action in particular)
	* put a bunch of the functions in MooArgs for calculating derivative args (like breaking an arg string into multiple
	  words) as well as functions that set the values for certain circumstances
	* make various functions in thing.cpp (like those in utils right now)
	* fill out the MooArgs class
	* fill in the various functions in MooUser for basic communications
	* implement basic builtin functions like 'tell' and 'look'
	* should you try to replace all make_string references with std::string stuff?

	* make an IRC pseudo server which acts like a single-IRC-servered network and communicates with clients via server-to-client
	  IRC protocol, but which cannot connect to an existing IRC server.
	* in future, we could make a client (klunky), services (is this even possible), or server based IRC interface.  If it requires
	  (or would be easier to use) some existing code (like perhaps even writing a module for anope), you could easily just have it
	  act as an RPC client which connects via socket to the moo server's RPC server (which we have yet to figure out)

	* add a function that MooInterface can call on a task to notify it that the interface is being destroyed
	* modify the handle() function to do something like close the interface if an error occurs?

	* data/maps/ is not a good dir name.  Perhaps it should be data/objs/ or soemthing like that





    Old Stuff:
	* make sdm able to use python and SDRL (and possibly lua) simultaneously but there is no need to
	  make it capable of supporting more than this.  Making it capable of *only* python would not be
	  terrible either because that's likely the only language worth using.
	* python would be like room.action("look") to run an action, room.get("desc") to get property, etc
	* the downside of python is it's manditory whitespace; perl would be nicer

	* should you change the position of the caller argument in all of the do_action util functions?
	* target in action_args should be named something else

	* make @destroy command
	* add a @write_world command
	* add a @get command for returning the raw property values
	* add functions to lua for util_expand_ref stuff
	* should you make the announce action add a "\n" before each output to the user in order to prevent
	  interrupting the current line being typed instead of putting it in all the places that generate
	  output sent to the announce action?
	* make the code use the "title" property instead of the "name" property for displaying the name
	  of an object
	* change the name of tell_view

	* parser format:   command[/modifier] [-flags] [object [preposition indirect-object]

	* the biggest problem with any parsing format will be for the get <object> from <container> command
	  specifically.  The object must be searched for in the container which is not normally searched
	  as a location for the direct object.  Either object searching can include an object specified in
	  the command, or wehre to search can be specified in the action definition, or just a string can
	  be passed and it will be up to the action code to resolve the string.
	* one alternative is to send an array of object pointers to the action using an args string or
	  or something but this means you have allocate everything and then deal with the complexity in
	  the actions themselves still
	* a thing you really should think about but that is hard to know the effects since you don't really
	  do too much of it now is calling actions from within other actions without using a string that gets
	  parsed.  Whatever parsing solution must somehow work with both methods of invocation but we don't
	  have a clear idea of when the 2 different methods would be used nor how we'll handling limiting
	  what actions can be called from the command line.  It is possible that we could end up just
	  having actions that are always called from command line and actions always called from other actions
	* either way i would very much be in favour of a central parser and argument checker which would
	  make the commands themselves simpler not having to do all the parsing themselves
	* can you use regexes to do parsing? or would that be waaaay too slow and painful?
	* either make the parse_args function handle more arg cases or make the other functions easier
	  to use.  Make parse_args work properly/nicely with the get/put/drop commands?
	* clean up/add parsing functions to lua to make it easy to parse the args
	* i don't like the parsing functions available
	* i don't like the way commands are parsed particularily the fact tha firstly, you can't specify a
	  partial name and secondly that things like "get the thing" doesn't work at all (and doesn't even
	  seem to print a proper error)
	* make object name matching match part of a word like if the name is "The Thing" somehow match "thing"
	* make sdm_interpreter_find_thing() use the aliases of an object for matching as well as doing partial
	  matching of the string given.
	* can you make object lookup in the interpreter try to match the whole command line and whatever
	  matches the best is used as the object name and the rest is passed as the args string?

	* should a list use the object itself to hold the next pointer (part of object) which means that
	  exact object can only be in one list at a time?
	* should objects have a pointer to the list they are contained in so that they can be removed from
	  that list when they are destroyed?

	* fix the 'get' action to actually use the second arg properly
	* how do you prevent a user from directly calling actions that he shouldn't call directly on the
	  command line
	* implement a permissions system for object modification
	* add command shortcuts like lambdamoo's \" for say and : for emote
	* add the ability for sdm_util_resolve_reference() to call actions on objects and to handle multiple
	  references such as $thing.location.name and such

	* have the telnet module more closely control the printing of the command prompt such that after
	  output has been generated, a command prompt in printed (will be hard to know when output is over).
	  You could have a special check in the main server loop that checks a flag set when output has been
	  sent and if output was sent, print the command prompt?? (complex and lots of border cases)
	* we'll have to add reference counting of objects at some point

	* add a jump_ok property and maybe even a distant_look_ok or something that allows looking at an
	  object without being nearby
	* perhaps you can add colour theming through the user properties and the expand string notify by
	  having <$caller.error> and so on type tags in string being printed using notify
	* make the look_self action tailor the description to the type of object it is describing (ie. don't
	  list the items a person is carrying)
	* how do you decide what things to print in the list of contents since you don't want to print all
	  objects such as exits and stuff (perhaps by calling a function on the object that makes it describe
	  itself)
	* make functions for setting the name and description of an object
	* add actions for manipulating things: get, give, drop, inventory, etc
	* convert all hardcoded id references to named references (such as the starting room in user and form)
	* make an "exits" command that prints the list of obvious exits and their descriptions
	* print the equipment, weapons, armour, etc seperately and/or provide commands that print only
	  one type
	* try to remove the direct references to sdm_user the the args of the processor virtual functions
	* try to make thing not directly reference user and world in it's load/save functions

	* should you add a flag to objects somewhere that specifies that the object should be written to a
	  seperate file (sdm_user) for checking when writing a container instead of a hardcoded check for user?
	* make the lua error print to the user (or at least optionally)

	* have an etc/telnet.xml file with <server> entries to run servers and the data on what registration
	  restrictions and objects to use will be there
	* should the connect/disconnect functions call an action on the object to allow for extra stuff to
	  be done?

Refactoring:

	* should "this" (thing) be passed seperately like it is now or just using the one in the args?
	* should you not use the ARGS macros?
	* make all types use init functions of the form "init_sdm_<name>_type" or else convert string and
	  number to *not* use that form

Structural Issues:

	* i don't like the sdm_moveto function in that the action it calls must guess what the hell is
	  supposed to be happening based on what the arguments are.  For example, if i steal an object from
	  another user, it would be moveto(me, obj, me, NULL) but that looks exactly like picking up an
	  object or getting an object out of a container.  It's only because the container is not owned by
	  me that it's stealing.
	* can/should there be a way of doing an overridden action? (knowingly passing an object to an action
	  on a parent of that object to avoid an overloaded action? (to change it's overt behaviour without
	  reimplementing the functionality) (eg. override the say command to prevent talking while asleep)
	* should you change format codes to something like bbcode ( [red] instead of <red> )

	* how do you get the thing to record information in when using a form?
	* how would you make different subselections in a form based on previous input (only ask a certain
	  question if the answer to a previous question was a certain answer)?
	* in lua, how do you tell if the result of an action is a number or a thing id?

	* should it be assumed that an interface subclass will always be used for a different type of
	  connection (like the telnet class that inherits from tcp instead of using a tcp object seperately)
	  in which case we can instead of using callback with a stored pointer, either just have the function
	  and passed the condition that occurred and the interface pointer or even specifically a virtual
	  function of the same type common for the whole class.  The extra data associated with that class
	  (like the user object for a telnet connection) can be stored in the subclass.  Having a single
	  handler per class would mean you would need to multiplex functions as they are now or else have
	  another function pointer that you call in telnet for doing the whole login process.  If we still
	  have the callback per object but just no ptr value, it just wouldn't be as easy to use an interface
	  for "some other" connection but we shouldn't have a need for that and if we do, we can make a
	  general subclass if we really need.
	* is the way we call the callbacks in sdm_interface_select right in that we call each callback
	  once *for each condition* so the same function is called with the same interface for each
	  condition that it's registered for.  How does the callback tell the difference?  should there
	  really be 3 callbacks?  Or should you only be able to handle one condition? or should the callback
	  only be called once and it's up to the handling routine to check each descriptor to see which one
	  is ready?  Isn't there a function called poll that can be used instead of select in those situations?

    Output Formatting/Interfaces:
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).
	* think about the processor system.  it might be good to seperate it such that if a raw xml client
	  was developed, it should be able to communicate directly with the code that handles telnet clients
	  directly ontop of the code that accepts the xml client essentially

Gerenal:

	* write and implement details on converting input received (in the server core format document)
	* tidy up the xml formatting in telnet and add theme tags (tags that indirectly refer to format)
	* add the ability for telnet to read user specific configuration data from the user data file
	* implement proper handling of telnet commands

	* make the login track invalid attempts and terminate the connection after a while
	* add a way to automatically timeout login attempts
	* make the login object use/store multiple methods of authentication (primarily for other interfaces)

	* make build.pl only use the cflags for certain modules as needed instead of all modules being
	  compiled with the flags for all embedded languages for example
	* make it easy (through data.c) to have multiple "data modules" (only needed for maps and stuff)
	* make it possible for the command prompt to display info (call a function to generate it)

	* add a release function to SDRL to release the expr when the sdrl action object is destroyed
	* make a proper (if ) and any other handy forms to make it easy to program
	* make a sdrl unparser (perhaps as part of SDRL itself)
	* make functions for controlling the properties of sdm_things
	* make functions for moving objects between containers

Features:

	* make the server multithreaded.  Perhaps "processors" (input handlers) could be threads.  You'd
	  need some kind of semaphore lock on the objects so that calling an action locks the object
	* multiple scripting languages: sdrl, lua
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #world or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #world channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface

	* you could have extra data in the xml map file for things like sound, graphics, etc. and have a
	  special client or clients (sdmc, written in C, maybe a flash/web based interface).  These clients
	  could connect using a different interface and processor but get into the same core and interact in
	  the same sort of way.  (interface -> processor -*-> API, where -*-> means many different calls).
	  The client could maybe have predownloaded the data or could pre-cache it automagically from the
	  server.  Maybe map data would be on the fly and tiles and sounds are precached.
	* Each room could have it's own tiled map and going out a room "exit" like a door would be the same
	  as in the text game, transporting you to another room.  Things would still operate on a room
	  basis, so fighting and picking up items and stuff doesn't change based on where you are in the
	  tiled room.  Maybe you might not even be able to move (such as if it's a web-based one).  On the
	  bottom part of the screen would be a console that prints a lot of the text that you would normally
	  see.

