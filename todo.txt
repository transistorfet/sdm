
    Discussion:

      Multiple Characters:
	* make it possible to play multiple characters at once, perhaps by having a special channel with the character's name
	  and use it as the control, like #realm for that character.  There could be a limit of 4 or so concurrent character logins
	  per connection.  You could be able to control a whole party through different channel windows.  Perhaps there could be a
	  number of 'characters' in the user object, and the user object can be in a different special non-playing area for social
	  MUDing, while his/her characters can be in various parts of the game area.  So maybe it should be #realm even, maybe
	  #social, and #realm-char can be used for each character.  It is possible to make #realm just a channel and use the evaluate
	  action to implement all world manipulation
	* it might be possible to do multiple characters such that you just make an object with all the same basic actions on it
	  as a user object such that they forward the calls on to the user object accordingly.  The user would then direct all possible
	  output to the character object by calling actions in a certain channel (possibly the character itself... is this possible??)
	  Mighten this require the use of child/parent object linking (perhaps even just a property list of the child objects, which
	  could be maintained by the clone function or something).

      Interface Methods:
	* by making a subclass of both user and task, which can be used in place of both (task is already ok for this, but user would
	  need some more virtual functions), it would be possible to easily implement an RCP break, such all code can be used to make
	  combinations of either the server or client side of the connection, with minimal effort.  ie. function calls to task, to
	  write to user, can be redirected over an RPC connection, and come out the other side, just as the other side of the function
	  call.  Therefore, we need to work on the RPC system, the IRC system, and the telnet system =P
	* the 2 other IRC interface methods (client connected as TheRealm, privmsgs are directly interpreted as commands, output is
	  directly printed, exactly the same as it would appear on telnet (more or less), -OR- server based, either the same as the
	  client (but with services-like permissions), or ... actually the method with #realm wont work with multiple IRC servers,
	  since all users associated with that channel will receive the same text, so everyone will recieve everyone else's private
	  traffic.  #realm could be use for only talking, with notices being sent for status messages, but that would get really
	  annoying since the notices might appear in other windows (dependant on client).  However, a system of #324 numeric channels
	  or something like that would still be possible (channels could be +si or something, so that you can only join if you are
	  forcejoin'd by TheRealm.)  (Note: the number used in numeric channels cannot be the room unless you are force join/part'd)
	* should MooInterface use a MooTask as the handler, or should it make a custom handler class like MooTimer does?

      MultiTasking:
	* perhaps you could add a lock/unlock method pair to MooObject or MooThing such that you pass it a pointer to the user (or
	  object, or task, or something) that is trying to lock an object.  If you are using multithreading, it will use a semaphore
	  or else just a bit and if successfully lock, will save the pointer passed to it.  That pointer can then be used to determine
	  who is performing an operation on that object (for permission checking) while at the same time allowing multithreading
	* we could have queued actions (or a special param or something passed to do_action) such that the action data can be copied
	  and placed in a queue to be evaluated later (namely when the object is unlocked, when doing multithreading and stuff).

      Miscellaneous:
	* the editor task could be implemented via whatever protocol by just passing all the code to the client, allowing it to
	  locally edit it, and then passing it back.  Even if an online (server-side) editor is used, it could store all the code in
	  a buffer, edit it, and then pass it all back when done.  How will editing work through IRC?
	* how will you be able to do register/create_character when you need to ask a bunch of questions.  It would be nice if it
	  was interactive.  It could possibly be implemented, such that .say gets redirected to a thing (perhaps by placing the user in
	  the thing itself, like a room. thing->do_action("say")).  We could alternatively have the registration "thing" call notify
	  with a special message telling it to prompt the user for input and returning it.  The task responding to the notify (or
	  possibly the user's notify function which mearly calls task's notify. NO IT SHOULD BE POSSIBLY FOR TASKS TO DO INTERFACE
	  SPECIFIC PROMPTS) can then redirect any input it receives to the registration thing
	* valid scheme characters: + - . * / < = > ! ? : $ _ & ~ ^
	* should you have permissions checks only where needed instead of all objects?  This would probably mean only MooThings would
	  have permissions controls, although it might be possible to have permission controls in MooObjectHash as well.

	* you could have NickServ and ChanServ as user-like objects which you can talk to for basic registration

    TODO:

	* we haven't fixed the problem with arrays and hashes and any complex data types where when a parent object is cloned, the
	  properties in the new Thing point to the same objects rather than being new but duplicate objects
	* MooMethod is still really ugly and should be changed

	* finish exception handling in frame
	* add debug field to event and fix debug message printing
	* fix inconsistent uses of nil and NULL

	* add a (check ...) function to do a permissions check and throw an error, so more complex checks can take place
	* get timers working

	* add a (sudo <object> <code>) function which elevates to the given object before executing the code (without requiring SUID)
	* add infinite loop protection
	* make it easier for C++ functions to use object array and hash functions with a permissions check
	* review all code for permissions check errors and bugs.  Evaluate system security.
	* fix realm_evaluate (object/target do_actions are disabled atm)
	* make some notify functions that can be called from MooCode that take certain format lines as input and output them to
	  the appropriate people in the room (like socials.dat in SMAUG)
	* i think it will have to be possible to have an inherited property either retain permissions or use the cloner's permissions
	  (make the cloner the owner) (sticky bit?).  Some properties need to be owned by the new object, and some need to be private.
	* you could have a locking mechanism in the frame itself similar to the task suid mechanism, where an unlock event is placed
	  on the stack.  Then, when a frame is going to be suspended, it can check for a lock and continue execution until the unlock
	  is reached.  It can also monitor for overrun and terminate the task or something.

	* if possible/needed, you could have a method on NickServ which goes through all the users at startup and makes sure they are
	  in the cryolocker or something

	* add support for notices from clients to other clients
	* add irc server-to-client pinging & connection timeouts
	* add flood protection of some kind (???)  (could this somehow be an add-on or a coded thing)

	* make an (undefine ...) command for completeness?
	* make a regex type (like string) that precompiles the expression, and can be directly parsed in using // notation
	* how can you delete MooThings from the system?
	* add return/return-from (how does lisp do it?) for breaking out of loops or returning early.  Perhaps we could use an exception
	  system such that a special event is pushed on to the stack and if a return or exception occurs, the stack is searched backwards
	  for the special event, and execution resumes with that event

	* add caching to environments
	* should you have private environments that are skipped when doing nested lookups?
	* should you store a pointer to frame in the env?  this might have a lot of problems 
	* fix 'quit' function to send an actual quit message to each client rather than just having the user part all channels

	* make sure it is not possible for a user to change his/her last_location value, logout, log back in, and get teleported to
	  some place they aren't supposed to be

	* modify attribute/colour formatting to use a stack of attribs, and to revert when closed tag is found
	* add a 'register' and 'login' commands to basics
	* implement an automatic testing system somehow (so you can verify the moocode core at least)
	* make it so that not all objects are loaded into the system (your ID assignment hack makes this impossible)

	* make a pet kitty cat object as a scripting test
	* make a mobile-equivallent of logarithm
	* make a bot which randomly pieces together lojban sentances (which may or may not make sense)
	* make some room games for testing, like trivia, maybe munchkin if you are ambitious, or go fish??
	* fill in all other IRC message processing


    Old Stuff:
	* make @destroy command

	* parser format:   command[/modifier] [-flags] [object [preposition indirect-object]

	* the biggest problem with any parsing format will be for the get <object> from <container> command
	  specifically.  The object must be searched for in the container which is not normally searched
	  as a location for the direct object.  Either object searching can include an object specified in
	  the command, or wehre to search can be specified in the action definition, or just a string can
	  be passed and it will be up to the action code to resolve the string.
	* make sdm_interpreter_find_thing() use the aliases of an object for matching as well as doing partial
	  matching of the string given.

	* how do you prevent a user from directly calling actions that he shouldn't call directly on the
	  command line
	* add command shortcuts like lambdamoo's \" for say and : for emote

	* have the telnet module more closely control the printing of the command prompt such that after
	  output has been generated, a command prompt in printed (will be hard to know when output is over).
	  You could have a special check in the main server loop that checks a flag set when output has been
	  sent and if output was sent, print the command prompt?? (complex and lots of border cases)

	* add a jump_ok property and maybe even a distant_look_ok or something that allows looking at an
	  object without being nearby
	* perhaps you can add colour theming through the user properties and the expand string notify by
	  having <$caller.error> and so on type tags in string being printed using notify
	* make the look_self action tailor the description to the type of object it is describing (ie. don't
	  list the items a person is carrying)
	* how do you decide what things to print in the list of contents since you don't want to print all
	  objects such as exits and stuff (perhaps by calling a function on the object that makes it describe
	  itself)
	* make functions for setting the name and description of an object
	* add actions for manipulating things: get, give, drop, inventory, etc
	* convert all hardcoded id references to named references (such as the starting room in user and form)
	* make an "exits" command that prints the list of obvious exits and their descriptions
	* print the equipment, weapons, armour, etc seperately and/or provide commands that print only
	  one type
	* try to remove the direct references to sdm_user the the args of the processor virtual functions
	* try to make thing not directly reference user and world in it's load/save functions

Structural Issues:

	* should you change format codes to something like bbcode ( [red] instead of <red> )

    Output Formatting/Interfaces:
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).

Gerenal:

	* write and implement details on converting input received (in the server core format document)
	* tidy up the xml formatting in telnet and add theme tags (tags that indirectly refer to format)

	* make the login track invalid attempts and terminate the connection after a while (for all interfaces?)
	* add a way to automatically timeout login attempts (for telnet)
	* implement proper handling of telnet commands

	* make it possible for the command prompt to display info (call a function to generate it)

Features:

	* focus on chatting/social rather than game (for now)
	* make the server multithreaded.  You'd need some kind of semaphore lock on the objects so that calling
	  an action locks the object
	* multiple scripting languages: sdrl, lua (Is this even worth it anymore?)
	* python would be like room.action("look") to run an action, room.get("desc") to get property, etc
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #realm or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #realm channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface
	* include a fully functional editor/construction kit, which could even save the word automatically
	* make a seperate program that can generate a visualization of some kind of parts of the database, so that you can make maps

	* you could have a protocol that would allow object based RPC (via xmlrpc or a custom system or something) such that you could
	  implement both a client connection (calling actions (methods) on the user thing object through which everything can be done)
	  or controlling other objects allowing out of process extensions
	* in future, we could make a client (klunky), services (is this even possible), or server based IRC interface.  If it requires
	  (or would be easier to use) some existing code (like perhaps even writing a module for anope), you could easily just have it
	  act as an RPC client to the Moo Server over a socket (which we have yet to figure out)
	* what are the merits of a disk-based thing database rather than having all objects in memory?  If we were to add this, it
	  could probably be done transparently to the existing code

	* you could have extra data in the xml map file for things like sound, graphics, etc. and have a
	  special client or clients (sdmc, written in C, maybe a flash/web based interface).  These clients
	  could connect using a different interface and processor but get into the same core and interact in
	  the same sort of way.  (interface -> processor -*-> API, where -*-> means many different calls).
	  The client could maybe have predownloaded the data or could pre-cache it automagically from the
	  server.  Maybe map data would be on the fly and tiles and sounds are precached.
	* Each room could have it's own tiled map and going out a room "exit" like a door would be the same
	  as in the text game, transporting you to another room.  Things would still operate on a room
	  basis, so fighting and picking up items and stuff doesn't change based on where you are in the
	  tiled room.  Maybe you might not even be able to move (such as if it's a web-based one).  On the
	  bottom part of the screen would be a console that prints a lot of the text that you would normally
	  see.

