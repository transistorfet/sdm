
	* how do you decide what things to print in the list of contents since you don't want to print all
	  objects such as exist and stuff

	* how do you get the thing to record information in for a form?
	* how would you make different subselections in a form based on previous input (only ask a certain
	  question if the answer to a previous question was a certain answer)?
	* since we put the user in the test room (50) when they connect and there is no other room to put them
	  in, when it's a user registering, the character isn't set up until later and when we put them in the
	  same room, the enter function wont be called and they wont get the initial "look" action
	* should the connect/disconnect functions call an action on the object to allow for extra stuff to
	  be done?

	* change sdm_interpreter_find_object to take a more generic object than sdm_user and to do more
	  searching.  It could take an sdm_thing and look inside the container that contains that thing and
	  if that thing is a container itself, it could look inside itself as well.  Also convert me and here
	  to the appropriate values
	* evaluate error handling for all interface stuff
	* evaluate error handling for all non-object code
	* implement the writing of actions in basic and lua

	* make it possible to get the object name given a pointer to the object type (either through a reverse
	  lookup or by storing the name in the type itself) for reading/writing properties and actions
	* you need a way to return an sdm_object from an action (where? is this really need, give example)

	* can you make object lookup in the interpreter try to match the whole command line and whatever
	  matches the best is used as the object name and the rest is passed as the args string?
	* have an etc/telnet.xml file with <server> entries to run servers and the data on what registration
	  restrictions and objects to use will be there

	* implement a permissions system for object modification
	* make some handy util static inline functions (what ones should i make?)
	* should you make container use the element name to lookup the type of object to create? (with the
	  requirement that the type must extend sdm_thing)
	* should you add a flag to objects somewhere that specifies that the object should be written to a
	  seperate file (sdm_user) for checking when writing a container instead of a hardcoded check for user?
	* (should you) add all object types to the object type list (who makes the calls?)
	* read and write the processor object from the user data file

	* should you have a method of finding certain locations/objects by name or something for things like
	  finding the starting room, safe room, dead room, cryolocker, etc
	* make the container_find() function continue searching for more complete matches
	* add command shortcuts like lambdamoo's \" for say and : for emote
	* add a system of relative object shortcut names specified in commands like "me" will refer to the
	  user object and "here" refers to the room the user is currently in
	* make system things configurable through xml files such as the port that telnet uses
	* write and implement details on input converting (in the server core format document)
	* tidy up the xml formatting in telnet perhaps and add theme tags (tags that indirectly refer to
	  format)
	* perhaps you can add a binary tree implementation for partial match searches such as commands that
	  can automatically be abbreviated.  You could also perhaps make the container store objects in a
	  in a binary tree for faster accessing

	* make various commands use the extra text passed in a command as a text modifier.  For example you
	  could say "give apple to trans carefully" and it will interpret the command like normal and the
	  'carefully' at the end would be tacked onto the output as "Wizard gives an apple to trans carefully"
	* make telnet use non-colour xml tags as theme colour specifiers

	* add the ability for telnet to read user specific configuration data from the user file
	* implement proper handling of telnet commands
	* have a linked list of processors in the user object with a pointer to the currently active one
	  and read/write the processor's data to the user file.  There should be a function for code to select
	  or create a new processor in the user as well as remove one.  The "next" pointer wolud be in proce..

	* make the login track invalid attempts and terminate the connection after a while
	* add a way to automatically timeout login attempts
	* accept a "-d" command line arg and fork to a daemon process
	* make the login object use/store multiple methods of authentication (primarily for other interfaces)

	* make build.pl only use the cflags for certain modules as needed instead of all modules being
	  compiled with the flags for all embedded languages for example
	* make it easy (through data.c) to have multiple "data modules" (only needed for maps and stuff)
	* make it possible for the command prompt to display info (call a function to generate it)


	* add a release function to SDRL to release the expr when the sdrl action object is destroyed
	* make a proper (if ) and any other handy forms to make it easy to program
	* make a sdrl unparser (perhaps as part of SDRL itself)
	* make functions for controlling the properties of sdm_things
	* make functions for moving objects between containers

Bugs:

	* the thing id for my user object was set to -1 and there was no error or warning generated.  I have
	  no idea how or when it happened.

Refactoring:

	* should you change the name of processor to something shorter and less confusing?
	* should you move processors and things to their own directory like interfaces/
	* should all scripting be supported only through actions and if so, i guess we should rename modules/
	  to be actions/ and put the action.c file in there just like we have for interfaces

Structural Issues:

	* how can you determine what xml element name to use for property objects without having to handle
	  each object type seperatly?
	* how will the "\n before line instead of after" affect telnet vs IRC?  Would this need to be somehow
	  abstracted so that it happens automatically yet is usable by both systems?
	* should you change format codes to something like bbcode ( [red] instead of <red> )

	* is the way we call the callbacks in sdm_interface_select right in that we call each callback
	  once *for each condition* so the same function is called with the same interface for each
	  condition that it's registered for.  How does the callback tell the difference?  should there
	  really be 3 callbacks?  Or should you only be able to handle one condition? or should the callback
	  only be called once and it's up to the handling routine to check each descriptor to see which one
	  is ready?  Isn't there a function called poll that can be used instead of select in those situations?

	* There is a need in the future to change the method of sending data to the interface other than just
	  colour formatting if we want to have an interactive system like a curses interface (much like using
	  vim on a telnet session).  The code for this would be in a processor subclass most likely inheriting
	  from sdm_interpreter.  This code (and the code of the processor objects) should almost be considered
	  like an actual system process of sorts almost like a client program running server-side.  In fact
	  through a special comptely independant process, this system could be achieved as if the client was
	  sshing to the server and running a local client program that connected to the moo server except it
	  would use the moo user database to authenticate the ssh session and would restrict the session to
	  only using that client program.  The system could instead send output formatted with xml to various
	  virtual functions associated with an I/O processor which works closely with an interface to render
	  that output on the client's machine.  We can modify the system at a later date to use these
	  different interfaces since I cannot accurately predict what will be require at this time.
	* modify interface read/write commands such that seperate channels of text can be supported in a
	  way that the interface receives the data seperately and must render it accordingly (?? this is
	  in order to support an IRC server interface where you have various seperate channels and then a
	  #world channel or something in which you interact but it gets very complicated, especially with
	  things like emote/me which would be rendered differently on telnet vs IRC and therefore rendering
	  of the command would ideally have to be passed to the interface which starts a slippery slide of
	  what gets handled by the interface).
	* think about the processor system.  it might be good to seperate it such that if a raw xml client
	  was developed, it should be able to communicate directly with the code that handles telnet clients
	  directly ontop of the code that accepts the xml client essentially

Features:

	* multiple scripting languages: sdrl, lua
	* multiserver somehow (loadbalancing) (perhaps using xml-rpc or something)
	* an irc server interface (such that you enter a channel #world or something and the server
	  sends output for the room you are currently in and people that enter the room will be be displayed
	  as join/leaves).  You could also enter multiple channels in a way where only the #world channel is
	  the game and the other channels are special "game" areas for chat only (normally accessable by
	  a special teleport command or something)
	* a super client extension thingie that is just a special xml command to the client to play a certain
	  piece of music that the client can optionally download through some other protocol
	* interactive interface (ncurses) through telnet as a mini-client (or should this complexity always
	  be offloaded to the clients to boost server-side performance?)
	* an irc client interface that is an irc bot that you pm through your irc client with to play the game.
	* an ssh interface

